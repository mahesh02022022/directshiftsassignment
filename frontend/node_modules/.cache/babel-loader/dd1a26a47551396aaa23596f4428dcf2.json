{"ast":null,"code":"import { createAsyncThunk, createSlice } from \"@reduxjs/toolkit\";\nimport { createUserWithEmailAndPassword, getCurrentUser, loginWithEmailAndPassword, logoutUserWithToken, requestAccessTokenWithRefreshToken, updateUserProfile } from \"../../api/sessionAPI\";\nconst initialState = {\n  currentUser: {\n    id: undefined,\n    email: undefined,\n    role: undefined,\n    createdAt: undefined\n  },\n  loading: true,\n  error: false,\n  errorMessages: [],\n  accessToken: undefined,\n  refreshToken: getRefreshToken(),\n  expiresIn: undefined,\n  tokenType: undefined\n}; // The function below is called a thunk and allows us to perform async logic. It\n// can be dispatched like a regular action: `dispatch(incrementAsync(10))`. This\n// will call the thunk with the `dispatch` function as the first argument. Async\n// code can then be executed and other actions can be dispatched. Thunks are\n// typically used to make async requests.\n\nexport const signUpUser = createAsyncThunk(\"session/signUpUser\", async (payload, _ref) => {\n  let {\n    rejectWithValue\n  } = _ref;\n  const response = await createUserWithEmailAndPassword(payload.email, payload.password);\n\n  if (response.errors) {\n    // The value we return becomes the `rejected` action payload\n    return rejectWithValue(response);\n  } // The value we return becomes the `fulfilled` action payload\n\n\n  return response;\n});\nexport const updateProfile = createAsyncThunk(\"session/updateProfile\", async (payload, _ref2) => {\n  let {\n    rejectWithValue\n  } = _ref2;\n  const response = await updateUserProfile(payload.currentPassword, payload.token, payload === null || payload === void 0 ? void 0 : payload.email, payload === null || payload === void 0 ? void 0 : payload.password);\n\n  if (response.errors) {\n    // The value we return becomes the `rejected` action payload\n    return rejectWithValue(response);\n  } // The value we return becomes the `fulfilled` action payload\n\n\n  return response;\n});\nexport const loginUser = createAsyncThunk(\"session/loginUser\", async (payload, _ref3) => {\n  let {\n    rejectWithValue\n  } = _ref3;\n  const loginResponse = await loginWithEmailAndPassword(payload.email, payload.password);\n\n  if (loginResponse.error) {\n    // The value we return becomes the `rejected` action payload\n    return rejectWithValue(loginResponse);\n  }\n\n  const userResponse = await getCurrentUser(loginResponse.access_token);\n\n  if (userResponse.error) {\n    // The value we return becomes the `rejected` action payload\n    return rejectWithValue(userResponse.data);\n  }\n\n  const response = { ...loginResponse,\n    ...userResponse\n  }; // The value we return becomes the `fulfilled` action payload\n\n  return response;\n});\nexport const logoutUser = createAsyncThunk(\"session/logoutUser\", async (payload, _ref4) => {\n  let {\n    rejectWithValue\n  } = _ref4;\n  const response = await logoutUserWithToken(payload); // if response has errors rejectwithvalue\n\n  console.log(response);\n\n  if (response.error) {\n    // The value we return becomes the `rejected` action payload\n    return rejectWithValue(response);\n  } // The value we return becomes the `fulfilled` action payload\n\n\n  return response;\n});\nexport const refreshAccessToken = createAsyncThunk(\"session/refreshAccessToken\", async (refreshToken, _ref5) => {\n  let {\n    rejectWithValue\n  } = _ref5;\n\n  if (!refreshToken) {\n    return rejectWithValue(\"No refresh token\");\n  }\n\n  const refreshResponse = await requestAccessTokenWithRefreshToken(refreshToken);\n\n  if (refreshResponse.error) {\n    // The value we return becomes the `rejected` action payload\n    return rejectWithValue(refreshResponse.data);\n  }\n\n  const userResponse = await getCurrentUser(refreshResponse.access_token);\n\n  if (userResponse.error) {\n    // The value we return becomes the `rejected` action payload\n    return rejectWithValue(userResponse.data);\n  }\n\n  const response = { ...refreshResponse,\n    ...userResponse\n  }; // The value we return becomes the `fulfilled` action payload\n\n  return response;\n});\nexport const sessionSlice = createSlice({\n  name: \"session\",\n  initialState,\n  // The `reducers` field lets us define reducers and generate associated actions\n  reducers: {\n    resetErrorState: state => {\n      state.error = false;\n      state.errorMessages = [];\n    }\n  },\n  // The `extraReducers` field lets the slice handle actions defined elsewhere,\n  // including actions generated by createAsyncThunk or in other slices.\n  extraReducers: builder => {\n    builder.addCase(signUpUser.pending, state => {\n      state.loading = true;\n      state.error = false;\n      state.errorMessages = [];\n    }).addCase(signUpUser.fulfilled, (state, action) => {\n      state.accessToken = action.payload.access_token;\n      state.refreshToken = action.payload.refresh_token;\n      state.expiresIn = action.payload.expires_in;\n      state.tokenType = action.payload.token_type;\n      state.currentUser = {\n        id: action.payload.id,\n        email: action.payload.email,\n        role: action.payload.role,\n        createdAt: action.payload.created_at\n      };\n      storeRefreshToken(action.payload.refresh_token);\n      state.loading = false;\n      state.error = false;\n      state.errorMessages = [];\n    }).addCase(signUpUser.rejected, (state, action) => {\n      state.loading = false;\n      state.error = true;\n      state.errorMessages = action.payload.errors;\n    }).addCase(loginUser.pending, state => {\n      state.loading = true;\n      state.error = false;\n      state.errorMessages = [];\n    }).addCase(loginUser.fulfilled, (state, action) => {\n      state.accessToken = action.payload.access_token;\n      state.refreshToken = action.payload.refresh_token;\n      state.expiresIn = action.payload.expires_in;\n      state.currentUser = {\n        id: action.payload.id,\n        email: action.payload.email,\n        role: action.payload.role,\n        createdAt: action.payload.created_at\n      };\n      storeRefreshToken(action.payload.refresh_token);\n      state.loading = false;\n      state.error = false;\n      state.errorMessages = [];\n    }).addCase(loginUser.rejected, (state, action) => {\n      state.loading = false;\n      state.error = true;\n      state.errorMessages = [\"Invalid credentials. Did you enter them correctly?\"];\n    }).addCase(refreshAccessToken.pending, state => {\n      state.loading = true;\n      state.error = false;\n      state.errorMessages = [];\n    }).addCase(refreshAccessToken.fulfilled, (state, action) => {\n      state.accessToken = action.payload.access_token;\n      state.refreshToken = action.payload.refresh_token;\n      state.expiresIn = action.payload.expires_in;\n      state.currentUser = {\n        id: action.payload.id,\n        email: action.payload.email,\n        role: action.payload.role,\n        createdAt: action.payload.created_at\n      };\n      storeRefreshToken(action.payload.refresh_token);\n      state.loading = false;\n      state.error = false;\n      state.errorMessages = [];\n    }).addCase(refreshAccessToken.rejected, (state, action) => {\n      state.loading = false;\n      state.error = true;\n    }).addCase(logoutUser.pending, state => {\n      state.loading = true;\n      state.error = false;\n      state.errorMessages = [];\n    }).addCase(logoutUser.fulfilled, (state, action) => {\n      state.currentUser = {\n        id: undefined,\n        email: undefined,\n        role: undefined,\n        createdAt: undefined\n      };\n      state.accessToken = undefined;\n      state.refreshToken = undefined;\n      state.expiresIn = undefined;\n      state.tokenType = undefined;\n      removeRefreshToken();\n      state.loading = false;\n      state.error = false;\n      state.errorMessages = [];\n    }).addCase(logoutUser.rejected, (state, action) => {\n      state.loading = false;\n      state.error = true;\n      state.errorMessages = [action.payload.error];\n    }).addCase(updateProfile.pending, state => {\n      state.loading = true;\n      state.error = false;\n      state.errorMessages = [];\n    }).addCase(updateProfile.fulfilled, (state, action) => {\n      state.accessToken = action.payload.access_token;\n      state.refreshToken = action.payload.refresh_token;\n      state.expiresIn = action.payload.expires_in;\n      state.tokenType = action.payload.token_type;\n      state.currentUser = {\n        id: action.payload.id,\n        email: action.payload.email,\n        role: action.payload.role,\n        createdAt: action.payload.created_at\n      };\n      storeRefreshToken(action.payload.refresh_token);\n      state.loading = false;\n      state.error = false;\n      state.errorMessages = [];\n    }).addCase(updateProfile.rejected, (state, action) => {\n      state.loading = false;\n      state.error = true;\n      state.errorMessages = action.payload.errors;\n    });\n  }\n});\nexport const {\n  resetErrorState\n} = sessionSlice.actions; // The function below is called a selector and allows us to select a value from\n// the state. Selectors can also be defined inline where they're used instead of\n// in the slice file. For example: `useSelector((state: RootState) => state.counter.value)`\n// export const selectCount = (state: RootState) => state.counter.value;\n// We can also write thunks by hand, which may contain both sync and async logic.\n// Here's an example of conditionally dispatching actions based on current state.\n\nexport default sessionSlice.reducer;\n\nfunction storeRefreshToken(token) {\n  localStorage.setItem(\"refreshToken\", token);\n}\n\nfunction removeRefreshToken() {\n  localStorage.removeItem(\"refreshToken\");\n}\n\nfunction getRefreshToken() {\n  return localStorage.getItem(\"refreshToken\");\n}","map":{"version":3,"sources":["C:/ruby_prg/7/react-wishlist-series/frontend/src/app/features/sessions/sessionSlice.tsx"],"names":["createAsyncThunk","createSlice","createUserWithEmailAndPassword","getCurrentUser","loginWithEmailAndPassword","logoutUserWithToken","requestAccessTokenWithRefreshToken","updateUserProfile","initialState","currentUser","id","undefined","email","role","createdAt","loading","error","errorMessages","accessToken","refreshToken","getRefreshToken","expiresIn","tokenType","signUpUser","payload","rejectWithValue","response","password","errors","updateProfile","currentPassword","token","loginUser","loginResponse","userResponse","access_token","data","logoutUser","console","log","refreshAccessToken","refreshResponse","sessionSlice","name","reducers","resetErrorState","state","extraReducers","builder","addCase","pending","fulfilled","action","refresh_token","expires_in","token_type","created_at","storeRefreshToken","rejected","removeRefreshToken","actions","reducer","localStorage","setItem","removeItem","getItem"],"mappings":"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","sourcesContent":["import { createAsyncThunk, createSlice, PayloadAction } from \"@reduxjs/toolkit\";\r\nimport { createUserWithEmailAndPassword, getCurrentUser, loginWithEmailAndPassword, logoutUserWithToken, requestAccessTokenWithRefreshToken, updateUserProfile } from \"../../api/sessionAPI\";\r\nimport { RootState, AppThunk } from \"../../store\";\r\n\r\n\r\nexport interface User {\r\n  id?: string;\r\n  email?: string;\r\n  role?: string;\r\n  createdAt?: string;\r\n}\r\n\r\nexport interface UserLoginData {\r\n  email: string;\r\n  password: string;\r\n}\r\n\r\nexport interface UserUpdateData {\r\n  currentPassword: string;\r\n  token: string | undefined;\r\n  email?: string;\r\n  password?: string;\r\n}\r\n\r\ninterface AuthState {\r\n  currentUser?: User;\r\n  loading: boolean;\r\n  error: boolean;\r\n  errorMessages: string[];\r\n  accessToken?: string;\r\n  refreshToken?: string | null;\r\n  expiresIn?: number;\r\n  tokenType?: string;\r\n  currentRoute?: string;\r\n}\r\n\r\nconst initialState: AuthState = {\r\n  currentUser: { \r\n    id: undefined,\r\n    email: undefined,\r\n    role: undefined,\r\n    createdAt: undefined\r\n  },\r\n  loading: true,\r\n  error: false,\r\n  errorMessages: [],\r\n  accessToken: undefined,\r\n  refreshToken: getRefreshToken(),\r\n  expiresIn: undefined,\r\n  tokenType: undefined\r\n}\r\n\r\n// The function below is called a thunk and allows us to perform async logic. It\r\n// can be dispatched like a regular action: `dispatch(incrementAsync(10))`. This\r\n// will call the thunk with the `dispatch` function as the first argument. Async\r\n// code can then be executed and other actions can be dispatched. Thunks are\r\n// typically used to make async requests.\r\nexport const signUpUser = createAsyncThunk(\r\n  \"session/signUpUser\",\r\n  async (payload: UserLoginData, { rejectWithValue }) => {\r\n    const response = await createUserWithEmailAndPassword(\r\n      payload.email, \r\n      payload.password\r\n      );\r\n    if (response.errors) {\r\n      // The value we return becomes the `rejected` action payload\r\n      return rejectWithValue(response);\r\n    }\r\n    \r\n    // The value we return becomes the `fulfilled` action payload\r\n    return response;\r\n  }\r\n);\r\n\r\nexport const updateProfile = createAsyncThunk(\r\n  \"session/updateProfile\",\r\n  async (payload: UserUpdateData, { rejectWithValue }) => {\r\n    const response = await updateUserProfile(\r\n      payload.currentPassword,\r\n      payload.token,\r\n      payload?.email,\r\n      payload?.password\r\n    );\r\n    if (response.errors) {\r\n      // The value we return becomes the `rejected` action payload\r\n      return rejectWithValue(response);\r\n    }\r\n    // The value we return becomes the `fulfilled` action payload\r\n    return response;\r\n  }\r\n);\r\n\r\nexport const loginUser = createAsyncThunk(\r\n  \"session/loginUser\",\r\n  async (payload: UserLoginData, { rejectWithValue }) => {\r\n    const loginResponse = await loginWithEmailAndPassword(\r\n      payload.email,\r\n      payload.password\r\n    );\r\n    if (loginResponse.error) {\r\n      // The value we return becomes the `rejected` action payload\r\n      return rejectWithValue(loginResponse);\r\n    }\r\n    const userResponse = await getCurrentUser(loginResponse.access_token);\r\n    if (userResponse.error) {\r\n      // The value we return becomes the `rejected` action payload\r\n      return rejectWithValue(userResponse.data);\r\n    }\r\n    const response = {\r\n      ...loginResponse,\r\n      ...userResponse,\r\n    };\r\n    // The value we return becomes the `fulfilled` action payload\r\n    return response;\r\n  }\r\n);\r\n\r\nexport const logoutUser = createAsyncThunk(\r\n  \"session/logoutUser\",\r\n  async (payload: string, { rejectWithValue }) => {\r\n    const response = await logoutUserWithToken(payload);\r\n    // if response has errors rejectwithvalue\r\n    console.log(response);\r\n    if (response.error) {\r\n      // The value we return becomes the `rejected` action payload\r\n      return rejectWithValue(response);\r\n    }\r\n    // The value we return becomes the `fulfilled` action payload\r\n    return response;\r\n  }\r\n);\r\n\r\nexport const refreshAccessToken = createAsyncThunk(\r\n  \"session/refreshAccessToken\",\r\n  async (refreshToken: string | undefined | null, { rejectWithValue }) => {\r\n    if (!refreshToken) {\r\n      return rejectWithValue(\"No refresh token\");\r\n    }\r\n\r\n    const refreshResponse = await requestAccessTokenWithRefreshToken(\r\n      refreshToken\r\n    );\r\n    if (refreshResponse.error) {\r\n      // The value we return becomes the `rejected` action payload\r\n      return rejectWithValue(refreshResponse.data);\r\n    }\r\n    const userResponse = await getCurrentUser(refreshResponse.access_token);\r\n    if (userResponse.error) {\r\n      // The value we return becomes the `rejected` action payload\r\n      return rejectWithValue(userResponse.data);\r\n    }\r\n    const response = {\r\n      ...refreshResponse,\r\n      ...userResponse,\r\n    };\r\n    // The value we return becomes the `fulfilled` action payload\r\n    return response;\r\n  }\r\n);\r\n\r\n\r\n\r\nexport const sessionSlice = createSlice({\r\n  name: \"session\",\r\n  initialState,\r\n  // The `reducers` field lets us define reducers and generate associated actions\r\n  reducers: {\r\n    resetErrorState: (state) => {\r\n      state.error = false;\r\n      state.errorMessages = [];\r\n    }\r\n  },\r\n  // The `extraReducers` field lets the slice handle actions defined elsewhere,\r\n  // including actions generated by createAsyncThunk or in other slices.\r\n  extraReducers: (builder) => {\r\n    builder\r\n      .addCase(signUpUser.pending, (state) => {\r\n        state.loading = true;\r\n        state.error = false;\r\n        state.errorMessages = [];\r\n      })\r\n      .addCase(signUpUser.fulfilled, (state, action: any) => {\r\n        state.accessToken = action.payload.access_token;\r\n        state.refreshToken = action.payload.refresh_token;\r\n        state.expiresIn = action.payload.expires_in;\r\n        state.tokenType = action.payload.token_type;\r\n        state.currentUser = {\r\n          id: action.payload.id,\r\n          email: action.payload.email,\r\n          role: action.payload.role,\r\n          createdAt: action.payload.created_at,\r\n        };\r\n        storeRefreshToken(action.payload.refresh_token);\r\n\r\n        state.loading = false;\r\n        state.error = false;\r\n        state.errorMessages = [];\r\n      })\r\n      .addCase(signUpUser.rejected, (state, action: any) => {\r\n        state.loading = false;\r\n        state.error = true;\r\n        state.errorMessages = action.payload.errors;\r\n      }).addCase(loginUser.pending, (state) => {\r\n        state.loading = true;\r\n        state.error = false;\r\n        state.errorMessages = [];\r\n      })\r\n      .addCase(loginUser.fulfilled, (state, action: any) => {\r\n        state.accessToken = action.payload.access_token;\r\n        state.refreshToken = action.payload.refresh_token;\r\n        state.expiresIn = action.payload.expires_in;\r\n        state.currentUser = {\r\n          id: action.payload.id,\r\n          email: action.payload.email,\r\n          role: action.payload.role,\r\n          createdAt: action.payload.created_at,\r\n        };\r\n        storeRefreshToken(action.payload.refresh_token);\r\n\r\n        state.loading = false;\r\n        state.error = false;\r\n        state.errorMessages = [];\r\n      })\r\n      .addCase(loginUser.rejected, (state, action: any) => {\r\n        state.loading = false;\r\n        state.error = true;\r\n        state.errorMessages = [\"Invalid credentials. Did you enter them correctly?\"];\r\n      }).addCase(refreshAccessToken.pending, (state) => {\r\n        state.loading = true;\r\n        state.error = false;\r\n        state.errorMessages = [];\r\n      })\r\n      .addCase(refreshAccessToken.fulfilled, (state, action: any) => {\r\n        state.accessToken = action.payload.access_token;\r\n        state.refreshToken = action.payload.refresh_token;\r\n        state.expiresIn = action.payload.expires_in;\r\n        state.currentUser = {\r\n          id: action.payload.id,\r\n          email: action.payload.email,\r\n          role: action.payload.role,\r\n          createdAt: action.payload.created_at,\r\n        };\r\n        storeRefreshToken(action.payload.refresh_token);\r\n\r\n        state.loading = false;\r\n        state.error = false;\r\n        state.errorMessages = [];\r\n      })\r\n      .addCase(refreshAccessToken.rejected, (state, action: any) => {\r\n        state.loading = false;\r\n        state.error = true;\r\n      })\r\n      .addCase(logoutUser.pending, (state) => {\r\n        state.loading = true;\r\n        state.error = false;\r\n        state.errorMessages = [];\r\n      })\r\n      .addCase(logoutUser.fulfilled, (state, action: any) => {\r\n        state.currentUser = {\r\n          id: undefined,\r\n          email: undefined,\r\n          role: undefined,\r\n          createdAt: undefined,\r\n        };\r\n        state.accessToken = undefined;\r\n        state.refreshToken = undefined;\r\n        state.expiresIn = undefined;\r\n        state.tokenType = undefined;\r\n        removeRefreshToken();\r\n\r\n        state.loading = false;\r\n        state.error = false;\r\n        state.errorMessages = [];\r\n      })\r\n      .addCase(logoutUser.rejected, (state, action: any) => {\r\n        state.loading = false;\r\n        state.error = true;\r\n        state.errorMessages = [action.payload.error];\r\n      })\r\n      .addCase(updateProfile.pending, (state) => {\r\n        state.loading = true;\r\n        state.error = false;\r\n        state.errorMessages = [];\r\n      })\r\n      .addCase(updateProfile.fulfilled, (state, action: any) => {\r\n        state.accessToken = action.payload.access_token;\r\n        state.refreshToken = action.payload.refresh_token;\r\n        state.expiresIn = action.payload.expires_in;\r\n        state.tokenType = action.payload.token_type;\r\n        state.currentUser = {\r\n          id: action.payload.id,\r\n          email: action.payload.email,\r\n          role: action.payload.role,\r\n          createdAt: action.payload.created_at,\r\n        };\r\n        storeRefreshToken(action.payload.refresh_token);\r\n\r\n        state.loading = false;\r\n        state.error = false;\r\n        state.errorMessages = [];\r\n      })\r\n      .addCase(updateProfile.rejected, (state, action: any) => {\r\n        state.loading = false;\r\n        state.error = true;\r\n        state.errorMessages = action.payload.errors;\r\n      });\r\n  },\r\n});\r\n\r\nexport const { resetErrorState } = sessionSlice.actions;\r\n\r\n// The function below is called a selector and allows us to select a value from\r\n// the state. Selectors can also be defined inline where they're used instead of\r\n// in the slice file. For example: `useSelector((state: RootState) => state.counter.value)`\r\n// export const selectCount = (state: RootState) => state.counter.value;\r\n\r\n// We can also write thunks by hand, which may contain both sync and async logic.\r\n// Here's an example of conditionally dispatching actions based on current state.\r\n\r\nexport default sessionSlice.reducer;\r\n\r\nfunction storeRefreshToken(token: string) {\r\n  localStorage.setItem(\"refreshToken\", token);\r\n}\r\n\r\nfunction removeRefreshToken() {\r\n  localStorage.removeItem(\"refreshToken\");\r\n}\r\n\r\nfunction getRefreshToken() {\r\n  return localStorage.getItem(\"refreshToken\");\r\n}"]},"metadata":{},"sourceType":"module"}